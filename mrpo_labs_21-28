# coding=utf-8
import pickle
from datetime import datetime


def running_time(func):
    """
    Декоратор, возвращающий длительность выполнения функции/метода
    :param func:
    :return: Время выполнения функции/метода
    """
    import time

    def wrapper(*args, **kwargs):
        """
        Метод возращающий время выполнения функции/метода
        :param args: указывает, что функция может быть вызвана с произвольным числом
        аргументов, при этом сами параметры обернуты в кортеж — последовательность значений,разделённых   запятым
        :param kwargs: указывает на произвольное количествоименованных параметров,
        при этом сами параметры обернтуры в словарь — неупорядоченный набор пар «ключ-значение».
        :return: Время выполнения функции/метода
        """
        start = time.time()
        return_value = func(*args, **kwargs)
        end = time.time()
        print('[*] Время выполнения: {} секунд.'.format(end - start))
        return return_value

    return wrapper


class Training(object):
    """
    Класс Training(Учения) описывает атрибуты: дата учения, место проведения, оценка;
    а также сущности Unit(Часть), Warship(Корабль)
    """

    def __init__(self, training_id=0, unit=0, warship=0, place=0, grade=0):
        """
        Метод конструктор, описывающий атрибуты: дата учения, место проведения, оценка;
        а также сущности Unit(Часть), Warship(Корабль)
        """
        self.id = training_id
        self.__unit = Unit(number=unit)
        self.__warship = Warship(number=warship)
        self.__date = datetime.today().date()
        self.__place = place
        self.__grade = grade

    def __str__(self):
        """
        Метод для строкового представления экземпляра класса
        :return: Строку формата: format(self.__unit.number, self.__warship.number, self.__date, self.__place,
        self.__grade)
        """
        return 'unit: {0}, warship: {1}, date: {2}, place: {3}, grade: {4}'.format(self.__unit.number,
                                                                                   self.__warship.number,
                                                                                   self.__date, self.__place,
                                                                                   self.__grade)

    @property
    def unit(self):
        """
        Свойство, возвращающее атрибут self.__unit
        :return: self.__unit
        """
        return self.__unit

    @property
    def warship(self):
        """
        Свойство, возвращающее атрибут self.__warship
        :return: self.__warship
        """
        return self.__warship

    @property
    def date(self):
        """
        Свойство, возвращающее атрибут self.__date
        :return: self.__date
        """
        return self.__date

    @property
    def place(self):
        """
        Свойство, возвращающее атрибут self.__place
        :return: self.__place
        """
        return self.__place

    @property
    def grade(self):
        """
        Свойство, возвращающее атрибут self.__grade
        :return: self.__grade
        """
        return self.__grade

    def add_unit(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__unit
        :param value: новое значение атрибута self.__unit
        :return: self.__unit
        """
        self.__unit = value
        return self.__unit

    def add_warship(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__warship
        :param value: новое значение атрибута self.__warship
        :return: self.__warship
        """
        self.__warship = value
        return self.__warship

    def add_date(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__date
        :param value: новое значение атрибута self.__date
        :return: self.__date
        """
        self.__date = value
        return self.__date

    def add_place(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__place
        :param value: новое значение атрибута self.__place
        :return: self.__place
        """
        self.__place = value
        return self.__place

    def add_grade(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__grade
        :param value: новое значение атрибута self.__grade
        :return: self.__grade
        """
        self.__grade = value
        return self.__grade


class TrainingDataBase(object):
    def __init__(self):
        self.filename = 'TrainingDB.pkl'
        self.database = {}
        self.index = 0
        try:
            self.open_database()
        except:
            self.save_database()

    def __iter__(self):
        for item in self.database:
            yield self.database[item]

    def next(self):
        if self.index == len(self.database):
            raise StopIteration
        self.index = self.index + 1
        return self.database[self.index]

    def prev(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.database[self.index]

    def open_database(self):
        with open(self.filename, 'rb') as f:
            self.database = pickle.load(f)
        f.close()

    def save_database(self):
        with open(self.filename, 'wb') as f:
            pickle.dump(self.database, f)
        f.close()

    def add_training(self, training_id=0, unit=0, warship=0, place=0, grade=0):
        training = Training(training_id, unit, warship, place, grade)
        if training.id in self.database.keys():
            print("Учение id {0} уже есть.\n".format(training_id))
            return
        self.database[training.id] = {}
        self.database[training.id]["id"] = training.id
        self.database[training.id]["unit"] = training.unit.number
        self.database[training.id]["warship"] = training.warship.number
        self.database[training.id]["place"] = training.place
        self.database[training.id]["grade"] = training.grade
        self.save_database()
        print("Учение id {} добавлено.\n".format(training_id))

    def get_training_by_id(self, training_id):
        for i in self.database.keys():
            if int(training_id) == i:
                return self.database[int(training_id)]
        return None

    def delete_training_by_id(self, training_id):
        for i in list(self.database):
            if int(training_id) == i:
                del self.database[int(training_id)]
                self.save_database()
                print("Учение id {} удалено.\n".format(training_id))

    def change_training_grade(self, training_id, grade):
        a = self.get_training_by_id(training_id)
        if not a:
            print("Учения id {} не добавлено. Повторите еще раз\n".format(training_id))
            return
        self.database[int(training_id)]["grade"] = grade
        self.save_database()
        print("Оценка учения id {0} изменена на {1}.\n".format(training_id, grade))


class TrainingTerm(object):
    def __init__(self):
        self.training_database = TrainingDataBase()

    def print_db(self):
        for training in self.training_database.database.values():
            print("---------------")
            print('id: {0}\nunit: {1}\nwarship: {2}\nplace: {3}\ngrade: {4}\n'.format(
                training["id"], training["unit"], training["warship"], training["place"], training["grade"]))
        print("---------------")

    def run(self):
        choice = 0
        choices = {
            1: lambda: self.print_db(),
            2: lambda: self.training_database.add_training(int((input('id: '))), int((input("unit: "))),
                                                           int((input("warship: "))), int((input("place: "))),
                                                           int((input("grade: ")))),
            3: lambda: self.training_database.delete_training_by_id(int(input('id: '))),
            4: lambda: self.training_database.change_training_grade(int(input('id: ')), int(input('grade: '))),
        }
        while choice != 5:
            print('1. print trainings database')
            print('2. add training')
            print('3. delete training')
            print('4. change training grade')
            print('5. BACK')
            choice = int(input('choise: '))
            if choice in choices:
                choices[choice]()


class Warship(object):
    """
    Класс Warship(Корабль) описывает атрибуты: идентификационный номер корабля, название корабля,тип корабля,
    дата создания, наработка, кол-во посадочных мест, устройстводвигателя (парусное, гребное, пароход,
    теплоход, турбоход, и т.д.), типпривода (самоходное, несамоходное), размещение корпуса
    (подводная лодка,ныряющее, полупогружное, и т.д.)
    """

    def __init__(self, warship_id=0, number=0, name=0, type_warship=0, date=0, life_time=0, seats=0, type_engine=0, type_drive_unit=0,
                 warship_hull=0):
        """
        Метод конструктор, описывающий атрибуты: идентификационный номер корабля, название корабля,тип корабля,
        дата создания, наработка, кол-во посадочных мест, устройстводвигателя (парусное, гребное, пароход,
        теплоход, турбоход, и т.д.), типпривода (самоходное, несамоходное), размещение корпуса
        (подводная лодка,ныряющее, полупогружное, и т.д.)
        """
        self.id = warship_id
        self.__number = number
        self.__name = name
        self.__type_warship = type_warship
        self.__date = date
        self.__life_time = life_time
        self.__seats = seats
        self.__type_engine = type_engine
        self.__type_drive_unit = type_drive_unit
        self.__warship_hull = warship_hull

    def __str__(self):
        """
        Метод для строкового представления экземпляра класса
        :return: Строку формата: format(self.__number, self.__name, self.__type_warship, self.__date, self.__life_time,
        self.__seats, self.__type_engine, self.__type_drive_unit, self.__warship_hull)
        """
        return 'number: {0}, name: {1}, type_warship: {2}, date: {3}, life_time: {4}, seats: {5}, type_engine: {6}, ' \
               'type_drive_unit: {7}, warship_hull: {8}'.format(self.__number, self.__name, self.__type_warship,
                                                                self.__date, self.__life_time, self.__seats,
                                                                self.__type_engine, self.__type_drive_unit,
                                                                self.__warship_hull)

    @property
    def number(self):
        """
        Свойство, возвращающее атрибут self.__number
        :return: self.__number
        """
        return self.__number

    @property
    def name(self):
        """
        Свойство, возвращающее атрибут self.__name
        :return: self.__name
        """
        return self.__name

    @property
    def type_warship(self):
        """
        Свойство, возвращающее атрибут self.__type_warship
        :return: self.__type_warship
        """
        return self.__type_warship

    @property
    def date(self):
        """
        Свойство, возвращающее атрибут self.__date
        :return: self.__date
        """
        return self.__date

    @property
    def life_time(self):
        """
        Свойство, возвращающее атрибут self.__life_time
        :return: self.__life_time
        """
        return self.__life_time

    @property
    def seats(self):
        """
        Свойство, возвращающее атрибут self.__seats
        :return: self.__seats
        """
        return self.__seats

    @property
    def type_engine(self):
        """
        Свойство, возвращающее атрибут self.__type_engine
        :return: self.__type_engine
        """
        return self.__type_engine

    @property
    def type_drive_unit(self):
        """
        Свойство, возвращающее атрибут self.__type_drive_unit
        :return: self.__type_drive_unit
        """
        return self.__type_drive_unit

    @property
    def warship_hull(self):
        """
        Свойство, возвращающее атрибут self.__warship_hull
        :return: self.__warship_hull
        """
        return self.__warship_hull

    def add_number(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__number
        :param value: новое значение атрибута self.__number
        :return: self.__number
        """
        self.__number = value
        return self.__number

    def add_name(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__name
        :param value: новое значение атрибута self.__name
        :return: self.__name
        """
        self.__name = value
        return self.__name

    def add_type_warship(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__type_warship
        :param value: новое значение атрибута self.__type_warship
        :return: self.__type_warship
        """
        self.__type_warship = value
        return self.__type_warship

    def add_date(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__date
        :param value: новое значение атрибута self.__date
        :return: self.__date
        """
        self.__date = value
        return self.__date

    def add_life_time(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__life_time
        :param value: новое значение атрибута self.__life_time
        :return: self.__life_time
        """
        self.__life_time = value
        return self.__life_time

    def add_seats(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__seats
        :param value: новое значение атрибута self.__seats
        :return: self.__seats
        """
        self.__seats = value
        return self.__seats

    def add_type_engine(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__type_engine
        :param value: новое значение атрибута self.__type_engine
        :return: self.__type_engine
        """
        self.__type_engine = value
        return self.__type_engine

    def add_type_drive_unit(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__type_drive_unit
        :param value: новое значение атрибута self.__type_drive_unit
        :return: self.__type_drive_unit
        """
        self.__type_drive_unit = value
        return self.__type_drive_unit

    def add_warship_hull(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__warship_hull
        :param value: новое значение атрибута self.__warship_hull
        :return: self.__warship_hull
        """
        self.__warship_hull = value
        return self.__warship_hull


class WarshipDataBase(object):
    def __init__(self):
        self.filename = 'WarshipDB.pkl'
        self.database = {}
        self.index = 0
        try:
            self.open_database()
        except:
            self.save_database()

    def __iter__(self):
        for item in self.database:
            yield self.database[item]

    def next(self):
        if self.index == len(self.database):
            raise StopIteration
        self.index = self.index + 1
        return self.database[self.index]

    def prev(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.database[self.index]

    def open_database(self):
        with open(self.filename, 'rb') as f:
            self.database = pickle.load(f)
        f.close()

    def save_database(self):
        with open(self.filename, 'wb') as f:
            pickle.dump(self.database, f)
        f.close()

    def add_warship(self, warship_id, number=0, name=0, type_warship=0, date=0, life_time=0, seats=0, type_engine=0,
                    type_drive_unit=0, warship_hull=0):
        warship = Warship(warship_id, number, name, type_warship, date, life_time, seats, type_engine, type_drive_unit,
                          warship_hull)
        if warship.id in self.database.keys():
            print("Учение id {0} уже есть.\n".format(warship_id))
            return
        self.database[warship.id] = {}
        self.database[warship.id]["id"] = warship.id
        self.database[warship.id]["number"] = warship.number
        self.database[warship.id]["name"] = warship.name
        self.database[warship.id]["type_warship"] = warship.type_warship
        self.database[warship.id]["date"] = warship.date
        self.database[warship.id]["life_time"] = warship.life_time
        self.database[warship.id]["seats"] = warship.seats
        self.database[warship.id]["type_engine"] = warship.type_engine
        self.database[warship.id]["type_drive_unit"] = warship.type_drive_unit
        self.database[warship.id]["warship_hull"] = warship.warship_hull
        self.save_database()
        print("Корабль id {} добавлено.\n".format(warship_id))

    def get_warship_by_id(self, warship_id):
        for i in self.database.keys():
            if int(warship_id) == i:
                return self.database[int(warship_id)]
        return None

    def delete_warship_by_id(self, warship_id):
        for i in list(self.database):
            if int(warship_id) == i:
                del self.database[int(warship_id)]
                self.save_database()
                print("Корабль id {} удалено.\n".format(warship_id))

    def change_warship_seats(self, warship_id, seats):
        a = self.get_warship_by_id(warship_id)
        if not a:
            print("Корабль id {} не добавлено. Повторите еще раз\n".format(warship_id))
            return
        self.database[int(warship_id)]["seats"] = seats
        self.save_database()
        print("Кол-во мест корабля id {0} изменен на {1}.\n".format(warship_id, seats))


class WarshipTerm(object):
    def __init__(self):
        self.warship_database = WarshipDataBase()

    def print_db(self):
        for warship in self.warship_database.database.values():
            print("---------------")
            print('id: {0}\nnumber: {1}\nname: {2}\ntype_warship: {3}\ndate: {4}\nlife_time: {5}\nseats: {6}\n'
                  'type_engine: {7}\ntype_drive_unit: {8}\nwarship_hull: {9}\n'.
                  format(warship["id"], warship["number"], warship["name"], warship["type_warship"], warship["date"],
                         warship["life_time"], warship["seats"], warship["type_engine"], warship["type_drive_unit"],
                         warship["warship_hull"]))
        print("---------------")

    def run(self):
        choice = 0
        choices = {
            1: lambda: self.print_db(),
            2: lambda: self.warship_database.add_warship(int(input('id: ')), int(input("number: ")),
                                                         int(input("name: ")), int(input("type_warship: ")),
                                                         int(input("date: ")), int(input('life_time: ')),
                                                         int(input("seats: ")), int(input("type_engine: ")),
                                                         int(input("type_drive_unit: ")), int(input("warship_hull: "))),
            3: lambda: self.warship_database.delete_warship_by_id((input('id: '))),
            4: lambda: self.warship_database.change_warship_seats(input('id: '), input('seats: '))
        }
        while choice != 5:
            print('1. print warships database')
            print('2. add warship')
            print('3. delete warship')
            print('4. change warship seats')
            print('5. BACK')
            choice = int(input('choise: '))
            if choice in choices:
                choices[choice]()


class Unit(object):
    """
    Класс Unit(Часть) описывает следующие атрибуты: номер части, место базирования, вид войск(морская авиация,
    морская пехота и т.д.); а также сущность Base(База флота)
    """

    def __init__(self, unit_id=0, number=0, base_name=0, place=0, type_army=0):
        """
        Метод конструктор, описывающий атрибуты: номер части, место базирования, вид войск(морская авиация,
        морская пехота и т.д.); а также сущность Base(База флота)
        """
        self.id = unit_id
        self.__number = number
        self.__base = Base(base_name)
        self.__place = place
        self.__type_army = type_army

    def __str__(self):
        """
        Метод для строкового представления экземпляра класса
        :return: Строку формата: format(self.__number, self.__base.name, self.__place, self.__type_army)
        """
        return 'number: {0}, base: {1}, place: {2}, type_army: {3}'.format(self.__number, self.__base.name,
                                                                           self.__place, self.__type_army)

    @property
    def number(self):
        """
        Свойство, возвращающее атрибут self.__number
        :return: self.__number
        """
        return self.__number

    @property
    def base(self):
        """
        Свойство, возвращающее атрибут self.__base
        :return: self.__base
        """
        return self.__base

    @property
    def place(self):
        """
        Свойство, возвращающее атрибут self.__place
        :return: self.__place
        """
        return self.__place

    @property
    def type_army(self):
        """
        Свойство, возвращающее атрибут self.__type_army
        :return: self.__type_army
        """
        return self.__type_army

    def add_number(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__number
        :param value: новое значение атрибута self.__number
        :return: self.__number
        """
        self.__number = value
        return self.__number

    def add_base(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__base
        :param value: новое значение атрибута self.__base
        :return: self.__base
        """
        self.__base = value
        return self.__base

    def add_place(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__place
        :param value: новое значение атрибута self.__place
        :return: self.__place
        """
        self.__place = value
        return self.__place

    def add_type_army(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__type_army
        :param value: новое значение атрибута self.__type_army
        :return: self.__type_army
        """
        self.__type_army = value
        return self.__type_army


class UnitDataBase(object):
    def __init__(self):
        self.filename = 'UnitDB.pkl'
        self.database = {}
        self.index = 0
        try:
            self.open_database()
        except:
            self.save_database()

    def __iter__(self):
        for item in self.database:
            yield self.database[item]

    def next(self):
        if self.index == len(self.database):
            raise StopIteration
        self.index = self.index + 1
        return self.database[self.index]

    def prev(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.database[self.index]

    def open_database(self):
        with open(self.filename, 'rb') as f:
            self.database = pickle.load(f)
        f.close()

    def save_database(self):
        with open(self.filename, 'wb') as f:
            pickle.dump(self.database, f)
        f.close()

    def add_unit(self, unit_id, number=0, base_name=None, place=0, type_army=0):
        unit = Unit(unit_id,  number, base_name, place, type_army)
        if unit.id in self.database.keys():
            print("Учение id {0} уже есть.\n".format(unit_id))
            return
        self.database[unit.id] = {}
        self.database[unit.id]["id"] = unit.id
        self.database[unit.id]["number"] = unit.number
        self.database[unit.id]["base_name"] = unit.base
        self.database[unit.id]["place"] = unit.place
        self.database[unit.id]["type_army"] = unit.type_army
        self.save_database()
        print("Часть id {} добавлено.\n".format(unit_id))

    def get_unit_by_id(self, unit_id):
        for i in self.database.keys():
            if int(unit_id) == i:
                return self.database[int(unit_id)]
        return None

    def delete_unit_by_id(self, unit_id):
        for i in list(self.database):
            if int(unit_id) == i:
                del self.database[int(unit_id)]
                self.save_database()
                print("Часть id {} удалено.\n".format(unit_id))

    def change_place(self, unit_id, place):
        a = self.get_unit_by_id( unit_id)
        if not a:
            print("Часть id {} не добавлено. Повторите еще раз\n".format(unit_id))
            return
        self.database[int( unit_id)]["place"] = place
        self.save_database()
        print("Место базирования части id {0} изменено на {1}.\n".format( unit_id, place))

class UnitTerm(object):
    def __init__(self):
        self.unit_database = UnitDataBase()

    def print_db(self):
        for unit in self.unit_database.database.values():
            print("---------------")
            print('id: {0}\nnumber: {1}\nbase_name: {2}\nplace: {3}\ntype_army: {4}\n'.
                  format(unit["id"], unit["number"], unit["base_name"], unit["place"], unit["type_army"]))
        print("---------------")

    def run(self):
        choice = 0
        choices = {
            1: lambda: self.print_db(),
            2: lambda: self.unit_database.add_unit(int(input('id: ')), int(input("number: ")),
                                                   int(input("base_name: ")), int(input("place: ")),
                                                   int(input("type_army: "))),
            3: lambda: self.unit_database.delete_unit_by_id((input('id: '))),
            4: lambda: self.unit_database.change_place((input('id: ')), (input('place: '))),
        }
        while choice != 5:
            print('1. print units database')
            print('2. add unit')
            print('3. delete unit')
            print('4. change place')
            print('5. BACK')
            choice = int(input('choise: '))
            if choice in choices:
                choices[choice]()


class UnitUsloviya(Unit):
    """
    Класс UnitUsloviya(Условия части) описывает следующие атрибуты: опасность, снараженность, индекс качества условий
    """

    def __init__(self, number, snaryajenie=0, dangerous=0, index=0):
        """
        Метод конструктор, описывающий атрибуты: опасность, снараженность, индекс качества условий
        """
        super(UnitUsloviya, self).__init__(number)
        self.__dangerous = dangerous
        self.__snaryajenie = snaryajenie
        self.__index = index

    def __str__(self):
        """
        Метод для строкового представления экземпляра класса
        :return: Строку формата: format(self.number, self.__snaryajenie, self.__dangerous, self.__index)
        """
        return 'number: {0}, snaryajenie: {1}, dangerous: {2}, index: {3}'. \
            format(self.number, self.__snaryajenie, self.__dangerous, self.__index)

    @property
    def dangerous(self):
        """
        Свойство, возвращающее атрибут self.__dangerous
        :return: self.__dangerous
        """
        return self.__dangerous

    @property
    def snaryajenie(self):
        """
        Свойство, возвращающее атрибут self.__snaryajenie
        :return: self.__snaryajenie
        """
        return self.__snaryajenie

    @property
    def index(self):
        """
        Свойство, возвращающее атрибут self.__index
        :return: self.__index
        """
        return self.__index

    def index_value(self):
        """
        Метод, вычисляющий значение атрибута self.__index
        :return: self.__index
        """
        self.__index = self.__snaryajenie - self.__dangerous

    def check_dangerous(self):
        """
        Метод проверки корректности атрибута self.__dangerous
        :return: Строку с ошибкой
        """
        try:
            if self.__dangerous <= 0 or self.__dangerous >= 10:
                raise DangerousException(self.__dangerous)
        except DangerousException as error:
            self.__dangerous = 0
            print(error)


class DangerousException(Exception):
    """
    Класс DangerousException(Исключение опасности) описывает исключение атрибута опасность класса UnitUsloviya
    """

    def __init__(self, value):
        """
        Метод конструктор, описывающий атрибуты: значение
        """
        self.value = value

    def __str__(self):
        """
        Метод для строкового представления экземпляра класса
        :return: Строку формата: format(self.value)
        """
        return 'invalid dangerous {0}'.format(self.value)


class Base(object):
    """
    Класс Часть описывает следующие атрибуты: название базы, географическое расположение, кол-во частей
    """

    def __init__(self, base_id=0, name='Arh', place='Rus', count_units=0):
        """
        Метод конструктор, описывающий атрибуты: название базы, географическое расположение, кол-во частей
        """
        self.id = base_id
        self.__name = name
        self.__place = place
        self.__count_units = count_units
        self.__queue = []

    def __str__(self):
        """
        Метод для строкового представления экземпляра класса
        :return: Строку формата: format(self.__name, self.__place, self.__count_units)
        """
        return 'name: {0}, place: {1}, count_units: {2}'.format(self.__name, self.__place, self.__count_units)

    def __add__(self, value):
        """
        Метод, увеличивающий атрибут self.__count_units на заданное значение, а также добавляющий это значение в
        список self.__queue
        :param value: Значение, на которое увеличивается атрибут self.__count_units
        """
        self.__count_units += value
        self.__queue.append(BaseChange(value))

    def __sub__(self, value):
        """
        Метод, уменьшающий атрибут self.__count_units на заданное значение, а также добавляющий это значение в
        список self.__queue
        :param value: Значение, на которое уменьшается атрибут self.__count_units
        """
        self.__count_units -= value
        self.__queue.append(BaseChange(value))

    @property
    def name(self):
        """
        Свойство, возвращающее атрибут self.__name
        :return: self.__name
        """
        return self.__name

    @property
    def place(self):
        """
        Свойство, возвращающее атрибут self.__place
        :return: self.__place
        """
        return self.__place

    @property
    def count_units(self):
        """
        Свойство, возвращающее атрибут self.__count_units
        :return: self.__count_units
        """
        return self.__count_units

    @property
    def queue(self):
        """
        Свойство, возвращающее атрибут self.__queue
        :return: self.__queue
        """
        return self.__queue

    def add_name(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__name, а также добавляющий это значение в
        список self.__queue
        :param value: новое значение атрибута self.__name
        :return: self.__name
        """
        self.__name = value
        self.__queue.append(BaseChange(value))
        return self.__name

    def add_place(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__place, а также добавляющий это значение в
        список self.__queue
        :param value: новое значение атрибута self.__place
        :return: self.__place
        """
        self.__place = value
        self.__queue.append(BaseChange(value))
        return self.__place

    def add_count_units(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__count_units, а также добавляющий это значение в
        список self.__queue
        :param value: новое значение атрибута self.__count_units
        :return: self.__count_units
        """
        self.__count_units = value
        self.__queue.append(BaseChange(value))
        return self.__count_units

    def get_new_value_count_units(self):
        """
        Метод возвращающий в строке первый элемент списка
        :return: Строку формата: format(item.when, item.new_value)
        """
        for i in range(len(self.__queue)):
            item = self.__queue.pop(0)
            print('when {0}, new_value {1}\n'.format(item.when, item.new_value))


class BaseDataBase(object):
    def __init__(self):
        self.filename = 'BaseDB.pkl'
        self.database = {}
        self.index = 0
        try:
            self.open_database()
        except:
            self.save_database()

    def __iter__(self):
        for item in self.database:
            yield self.database[item]

    def next(self):
        if self.index == len(self.database):
            raise StopIteration
        self.index = self.index + 1
        return self.database[self.index]

    def prev(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.database[self.index]

    def open_database(self):
        with open(self.filename, 'rb') as f:
            self.database = pickle.load(f)
        f.close()

    def save_database(self):
        with open(self.filename, 'wb') as f:
            pickle.dump(self.database, f)
        f.close()

    def add_base(self, base_id, name='Arh', place='Rus', count_units=0):
        base = Base(base_id, name, place, count_units)
        if base.id in self.database.keys():
            print("База id {0} уже есть.\n".format(base_id))
            return
        self.database[base.id] = {}
        self.database[base.id]["id"] = base.id
        self.database[base.id]["name"] = base.name
        self.database[base.id]["place"] = base.place
        self.database[base.id]["count_units"] = base.count_units
        self.save_database()
        print("База id {} добавлено.\n".format(base_id))

    def get_base_by_id(self, base_id):
        for i in self.database.keys():
            if int(base_id) == i:
                return self.database[int(base_id)]
        return None

    def delete_base_by_id(self, base_id):
        for i in list(self.database):
            if int(base_id) == i:
                del self.database[int(base_id)]
                self.save_database()
                print("База id {} удалено.\n".format(base_id))

    def change_base_count_units(self, base_id, count_units):
        a = self.get_base_by_id(base_id)
        if not a:
            print("База id {} не добавлено. Повторите еще раз\n".format(base_id))
            return
        self.database[int(base_id)]["count_units"] = count_units
        self.save_database()
        print("Кол-во частей базы id {0} изменен на {1}.\n".format(base_id, count_units))


class BaseTerm(object):
    def __init__(self):
        self.base_database = BaseDataBase()

    def print_db(self):
        for base in self.base_database.database.values():
            print("---------------")
            print('id: {0}\nname: {1}\nplace: {2}\ncount_units: {3}\n'.
                  format(base["id"], base["name"], base["place"], base["count_units"]))
        print("---------------")

    def run(self):
        choice = 0
        choices = {
            1: lambda: self.print_db(),
            2: lambda: self.base_database.add_base(int(input('id: ')), input("name: "),
                                                   input("place: "), int(input("count_units: "))),
            3: lambda: self.base_database.delete_base_by_id((input('id: '))),
            4: lambda: self.base_database.change_base_count_units((input('id: ')), (input('count_units: '))),
        }
        while choice != 5:
            print('1. print bases database')
            print('2. add base')
            print('3. delete base')
            print('4. change base count units')
            print('5. BACK')
            choice = int(input('choise: '))
            if choice in choices:
                choices[choice]()


class BaseChange(object):
    """
    Класс BaseChange (Изменение базы) описывает изменения атрибутов класса Base
    """

    def __init__(self, new_value):
        """
        Метод конструктор, описывающий атрибуты: сегодняшняя дата и изменившееся значение
        """
        self.when = datetime.today().date()
        self.new_value = new_value

    def __del__(self):
        """
        Деструктор, записывающий строку формата: format(self.when, self.new_value) в файл 'Base.txt'
        :return:
        """
        with open('Base.txt', 'a') as B:
            B.write('when {0}, new_value {1}\n'.format(self.when, self.new_value))


class BaseType(Base):
    """
    Класс BaseType (Тип базы) описывает атрибуты: тип базы и нгазавание (атрибут родительского класса Base)
    """

    def __init__(self, name='Name', count_units=0, base_type=None):
        """
        Метод конструктор, описывающий атрибуты: тип базы и нгазавание (атрибут родительского класса Base)
        """
        super(BaseType, self).__init__(name=name, count_units=count_units)
        self.base_type = base_type
    @running_time
    def base_type_is(self):
        """
        Метод вычисляющий значение атрибута self.base_type
        :return: self.base_type
        """
        if self.count_units < 5:
            self.base_type = 'small'
        elif self.count_units < 15:
            self.base_type = 'medium'
        else:
            self.base_type = 'huge'

    def __str__(self):
        """
        Метод для строкового представления экземпляра класса
        :return: Строку формата: format(self.name, self.base_type)
        """
        return 'name: {0}, base_type: {1}'.format(self.name, self.base_type)


class Personnel(object):
    """
    Класс Personnel(Личный состав) опичывает следующие атрибуты: фамилия, часть, должность, год рождения,
    годпоступления на службу, выслуга лет, наград
    """

    def __init__(self, personnel_id=0, surname=0, unit=0, post=0, birthday=0, date_of_employment=0, experience=0, awards=0):
        """
        Метод конструктор, описывающий атрибуты: фамилия, часть, должность, год рождения, годпоступления на службу,
        выслуга лет, наград.
        """
        self.id = personnel_id
        self.__surname = surname
        self.__unit = Unit(unit)
        self.__post = post
        self.__birthday = birthday
        self.__date_of_employment = date_of_employment
        self.__experience = experience
        self.__awards = awards

    def __str__(self):
        """
        Метод для строкового представления экземпляра класса
        :return: Строку формата: format(self.__surname, self.__unit.number, self.__post, self.__birthday,
        self.__date_of_employment, self.__experience, self.__awards)
        """
        return 'surname: {0}, unit: {1}, post: {2}, birthday: {3}, date_of_employment: {4}, ' \
               'experience: {5}, awards: {6},'.format(self.__surname, self.__unit.number, self.__post,
                                                      self.__birthday, self.__date_of_employment, self.__experience,
                                                      self.__awards)

    @property
    def surname(self):
        """
        Свойство, возвращающее атрибут self.__surname
        :return: self.__surname
        """
        return self.__surname

    @property
    def unit(self):
        """
        Свойство, возвращающее атрибут self.__unit
        :return: self.__unit
        """
        return self.__unit

    @property
    def post(self):
        """
        Свойство, возвращающее атрибут self.__post
        :return: self.__post
        """
        return self.__post

    @property
    def birthday(self):
        """
        Свойство, возвращающее атрибут self.__birthday
        :return: self.__birthday
        """
        return self.__birthday

    @property
    def date_of_employment(self):
        """
        Свойство, возвращающее атрибут self.__date_of_employment
        :return: self.__date_of_employment
        """
        return self.__date_of_employment

    @property
    def experience(self):
        """
        Свойство, возвращающее атрибут self.__experience
        :return: self.__experience
        """
        return self.__experience

    @property
    def awards(self):
        """
        Свойство, возвращающее атрибут self.__awards
        :return: self.__awards
        """
        return self.__awards

    def add_surname(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__surname
        :param value: новое значение атрибута self.__surname
        :return: self.__surname
        """
        self.__surname = value
        return self.__surname

    def add_unit(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__unit
        :param value: новое значение атрибута self.__unit
        :return: self.__unit
        """
        self.__unit = value
        return self.__unit

    def add_post(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__post
        :param value: новое значение атрибута self.__post
        :return: self.__post
        """
        self.__post = value
        return self.__post

    def add_birthday(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__count_units
        :param value: новое значение атрибута self.__count_units
        :return: self.__count_units
        """
        self.__birthday = value
        return self.__birthday

    def add_date_of_employment(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__date_of_employment
        :param value: новое значение атрибута self.__date_of_employment
        :return: self.__date_of_employment
        """
        self.__date_of_employment = value
        return self.__date_of_employment

    def add_experience(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__experience
        :param value: новое значение атрибута self.__experience
        :return: self.__experience
        """
        self.__experience = value
        return self.__experience

    def add_awards(self, value):
        """
        Метод, получающий значение и присваивающий его к атрибуту self.__awards
        :param value: новое значение атрибута self.__awards
        :return: self.__awards
        """
        self.__awards = value
        return self.__awards


class PersonnelDataBase(object):
    def __init__(self):
        self.filename = 'PersonnelDB.pkl'
        self.database = {}
        self.index = 0
        try:
            self.open_database()
        except:
            self.save_database()

    def __iter__(self):
        for item in self.database:
            yield self.database[item]

    def next(self):
        if self.index == len(self.database):
            raise StopIteration
        self.index = self.index + 1
        return self.database[self.index]

    def prev(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.database[self.index]

    def open_database(self):
        with open(self.filename, 'rb') as f:
            self.database = pickle.load(f)
        f.close()

    def save_database(self):
        with open(self.filename, 'wb') as f:
            pickle.dump(self.database, f)
        f.close()

    def add_personnel(self, personnel_id=0, surname=0, unit=0, post=0, birthday=0, date_of_employment=0, experience=0, awards=0):
        personnel = Personnel(personnel_id, surname, unit, post, birthday, date_of_employment, experience, awards)
        if personnel.id in self.database.keys():
            print("Человек id {0} уже есть.\n".format(personnel_id))
            return
        self.database[personnel.id] = {}
        self.database[personnel.id]["id"] = personnel.id
        self.database[personnel.id]["surname"] = personnel.surname
        self.database[personnel.id]["unit"] = personnel.unit
        self.database[personnel.id]["post"] = personnel.post
        self.database[personnel.id]["birthday"] = personnel.birthday
        self.database[personnel.id]["date_of_employment"] = personnel.date_of_employment
        self.database[personnel.id]["experience"] = personnel.experience
        self.database[personnel.id]["awards"] = personnel.awards
        self.save_database()
        print("Человек id {} добавлено.\n".format(personnel_id))

    def get_personnel_by_id(self, personnel_id):
        for i in self.database.keys():
            if int(personnel_id) == i:
                return self.database[int(personnel_id)]
        return None

    def delete_personnel_by_id(self, personnel_id):
        for i in list(self.database):
            if int(personnel_id) == i:
                del self.database[int(personnel_id)]
                self.save_database()
                print("Человек id {} удалено.\n".format(personnel_id))

    def change_unit(self, personnel_id, unit):
        a = self.get_personnel_by_id(personnel_id)
        if not a:
            print("Человек id {} не добавлено. Повторите еще раз\n".format(personnel_id))
            return
        self.database[int(personnel_id)]["unit"] = unit
        self.save_database()
        print("Часть человека id {0} изменена на {1}.\n".format(personnel_id, unit))


class PersonnelTerm(object):
    def __init__(self):
        self.personnel_database = PersonnelDataBase()

    def print_db(self):
        for personnel in self.personnel_database.database.values():
            print("---------------")
            print('id: {0}\nsurname: {1}\nunit: {2}\npost: {3}\nbirthday: {4}\ndate_of_employment: {5}\nexperience: {6}\n'
                  'awards: {7}\n'.
                  format(personnel["id"], personnel["surname"], personnel["unit"], personnel["post"], personnel["birthday"],
                         personnel["date_of_employment"], personnel["experience"], personnel["awards"]))
        print("---------------")

    def run(self):
        choice = 0
        choices = {
            1: lambda: self.print_db(),
            2: lambda: self.personnel_database.add_personnel(int(input('id: ')), int(input("surname: ")),
                                                             int(input("unit: ")), int(input("post: ")),
                                                             int(input("birthday: ")), int(input('date_of_employment: ')),
                                                             int(input("experience: ")), int(input("awards: "))),
            3: lambda: self.personnel_database.delete_personnel_by_id((input('id: '))),
            4: lambda: self.personnel_database.change_unit((input('id: ')), input('unit: ')),
        }
        while choice != 5:
            print('1. print personneles database')
            print('2. add personnel')
            print('3. delete personnel')
            print('4. change unit')
            print('5. BACK')
            choice = int(input('choise: '))
            if choice in choices:
                choices[choice]()


class PersistenceTraining(object):
    """
    Класс PersistenceTraining описывает сериализацию и десериализацию класса Training
    """

    @staticmethod
    def serialize(amount):
        """
        Метод сериализации экземпляра класса
        :param amount: Экземпляр класаа
        """
        with open('Training.pkl', 'wb') as Tp:
            pickle.dump(amount, Tp)
        Tp.close()

    @staticmethod
    def deserialize():
        """
        Метод десериализации экземпляра класса
        :return: Экземпляр класса
        """
        with open('Training.pkl', 'rb') as Tp:
            amount = pickle.load(Tp)
        Tp.close()
        return amount


class PersistenceWarship(object):
    """
    Класс PersistenceWarship описывает сериализацию и десериализацию класса Warship
    """

    @staticmethod
    def serialize(amount):
        """
        Метод сериализации экземпляра класса
        :param amount: Экземпляр класаа
        """
        with open('Warship.pkl', 'wb') as Wp:
            pickle.dump(amount, Wp)
        Wp.close()

    @staticmethod
    def deserialize():
        """
        Метод десериализации экземпляра класса
        :return: Экземпляр класса
        """
        with open('Warship.pkl', 'rb') as Wp:
            amount = pickle.load(Wp)
        Wp.close()
        return amount


class PersistenceUnit(object):
    """
    Класс PersistenceUnit описывает сериализацию и десериализацию класса Unit
    """

    @staticmethod
    def serialize(amount):
        """
        Метод сериализации экземпляра класса
        :param amount: Экземпляр класаа
        """
        with open('Unit.pkl', 'wb') as Up:
            pickle.dump(amount, Up)
        Up.close()

    @staticmethod
    def deserialize():
        """
        Метод десериализации экземпляра класса
        :return: Экземпляр класса
        """
        with open('Unit.pkl', 'rb') as Up:
            amount = pickle.load(Up)
        Up.close()
        return amount


class PersistenceBase(object):
    """
    Класс PersistenceBase описывает сериализацию и десериализацию класса Base
    """

    @staticmethod
    def serialize(amount):
        """
        Метод сериализации экземпляра класса
        :param amount: Экземпляр класаа
        """
        with open('Base.pkl', 'wb') as Bp:
            pickle.dump(amount, Bp)
        Bp.close()

    @staticmethod
    def deserialize():
        """
        Метод десериализации экземпляра класса
        :return: Экземпляр класса
        """
        with open('Base.pkl', 'rb') as Bp:
            amount = pickle.load(Bp)
        Bp.close()
        return amount


class PersistencePersonnel(object):
    """
    Класс PersistencePersonnel описывает сериализацию и десериализацию класса Personnel
    """

    @staticmethod
    def serialize(amount):
        """
        Метод сериализации экземпляра класса
        :param amount: Экземпляр класаа
        """
        with open('Personnel.pkl', 'wb') as Pp:
            pickle.dump(amount, Pp)
        Pp.close()

    @staticmethod
    def deserialize():
        """
        Метод десериализации экземпляра класса
        :return: Экземпляр класса
        """
        with open('Personnel.pkl', 'rb') as Pp:
            amount = pickle.load(Pp)
        Pp.close()
        return amount


if __name__ == '__main__':
    ch = 0
    chs = {
        1: lambda: TrainingTerm().run(),
        2: lambda: WarshipTerm().run(),
        3: lambda: UnitTerm().run(),
        4: lambda: BaseTerm().run(),
        5: lambda: PersonnelTerm().run()
    }
    while ch != 6:
        print('1. training db')
        print('2. warship db')
        print('3. unit db')
        print('4. base db')
        print('5. personnel db')
        print('6. exit')
        ch = int(input('choise: '))
        if ch in chs:
            chs[ch]()

